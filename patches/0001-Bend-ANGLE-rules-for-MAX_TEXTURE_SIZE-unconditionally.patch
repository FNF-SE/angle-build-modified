From 172ecebcedb70e034bb6478112e1839d93d9ec06 Mon Sep 17 00:00:00 2001
From: Homura <egzozu.be.bas@gmail.com>
Date: Thu, 29 Jan 2026 23:27:44 +0300
Subject: [PATCH 1/4] bend ANGLE rules for `MAX_TEXTURE_SIZE` unconditionally.

Currently, reaching `MAX_TEXTURE_SIZE` has the effect of a black box. The creation fails and the behavior diverges vastly across backends, Without having the ability to realistically probe what the GPU can do, applications end up losing that capability.

Instead of making guesses, we give the GPU permission to try to create the texture and rely on backend validation and driver behavior that may either accept or reject the operation. It is not a good solution, but this method is a more transparent, consistent, and quite naturally aligned with hardware limits of the present, day than overly conservative clamping.
---
 src/libANGLE/Context.cpp                      | 16 +++++------
 .../renderer/d3d/d3d11/renderer11_utils.cpp   | 28 +------------------
 .../renderer/d3d/d3d9/renderer9_utils.cpp     |  2 +-
 src/libANGLE/renderer/gl/renderergl_utils.cpp | 14 +++++-----
 src/libANGLE/renderer/metal/DisplayMtl.mm     |  4 +--
 src/libANGLE/renderer/vulkan/CLDeviceVk.cpp   |  4 +--
 .../renderer/vulkan/vk_caps_utils.cpp         | 25 ++++++-----------
 src/libANGLE/renderer/wgpu/wgpu_utils.cpp     | 14 +++++-----
 8 files changed, 37 insertions(+), 70 deletions(-)

diff --git a/src/libANGLE/Context.cpp b/src/libANGLE/Context.cpp
index a120b4d..6d2144d 100644
--- a/src/libANGLE/Context.cpp
+++ b/src/libANGLE/Context.cpp
@@ -4253,9 +4253,9 @@ void Context::initCaps()
 
     // Apply/Verify implementation limits
     ANGLE_LIMIT_CAP(caps->maxDrawBuffers, IMPLEMENTATION_MAX_DRAW_BUFFERS);
-    ANGLE_LIMIT_CAP(caps->maxFramebufferWidth, IMPLEMENTATION_MAX_FRAMEBUFFER_SIZE);
-    ANGLE_LIMIT_CAP(caps->maxFramebufferHeight, IMPLEMENTATION_MAX_FRAMEBUFFER_SIZE);
-    ANGLE_LIMIT_CAP(caps->maxRenderbufferSize, IMPLEMENTATION_MAX_RENDERBUFFER_SIZE);
+    ANGLE_LIMIT_CAP(caps->maxFramebufferWidth, 16384);
+    ANGLE_LIMIT_CAP(caps->maxFramebufferHeight, 16384);
+    ANGLE_LIMIT_CAP(caps->maxRenderbufferSize, 16384);
     ANGLE_LIMIT_CAP(caps->maxColorAttachments, IMPLEMENTATION_MAX_DRAW_BUFFERS);
     ANGLE_LIMIT_CAP(caps->maxVertexAttributes, MAX_VERTEX_ATTRIBS);
     if (mDisplay->getFrontendFeatures().forceMinimumMaxVertexAttributes.enabled &&
@@ -4284,18 +4284,18 @@ void Context::initCaps()
 
     if (mWebGLContext && limitations.webGLTextureSizeLimit > 0)
     {
-        ANGLE_LIMIT_CAP(caps->max2DTextureSize, limitations.webGLTextureSizeLimit);
+        ANGLE_LIMIT_CAP(caps->max2DTextureSize, 16384);
         ANGLE_LIMIT_CAP(caps->max3DTextureSize, limitations.webGLTextureSizeLimit);
         ANGLE_LIMIT_CAP(caps->maxCubeMapTextureSize, limitations.webGLTextureSizeLimit);
         ANGLE_LIMIT_CAP(caps->maxArrayTextureLayers, limitations.webGLTextureSizeLimit);
-        ANGLE_LIMIT_CAP(caps->maxRectangleTextureSize, limitations.webGLTextureSizeLimit);
+        ANGLE_LIMIT_CAP(caps->maxRectangleTextureSize, 16384);
     }
 
-    ANGLE_LIMIT_CAP(caps->max2DTextureSize, IMPLEMENTATION_MAX_2D_TEXTURE_SIZE);
+    ANGLE_LIMIT_CAP(caps->max2DTextureSize, 16384);
     ANGLE_LIMIT_CAP(caps->maxCubeMapTextureSize, IMPLEMENTATION_MAX_CUBE_MAP_TEXTURE_SIZE);
     ANGLE_LIMIT_CAP(caps->max3DTextureSize, IMPLEMENTATION_MAX_3D_TEXTURE_SIZE);
-    ANGLE_LIMIT_CAP(caps->maxArrayTextureLayers, IMPLEMENTATION_MAX_2D_ARRAY_TEXTURE_LAYERS);
-    ANGLE_LIMIT_CAP(caps->maxRectangleTextureSize, IMPLEMENTATION_MAX_2D_TEXTURE_SIZE);
+    ANGLE_LIMIT_CAP(caps->maxArrayTextureLayers, 16384);
+    ANGLE_LIMIT_CAP(caps->maxRectangleTextureSize, 16384);
 
     ANGLE_LIMIT_CAP(caps->maxShaderUniformBlocks[ShaderType::Vertex],
                     IMPLEMENTATION_MAX_VERTEX_SHADER_UNIFORM_BUFFERS);
diff --git a/src/libANGLE/renderer/d3d/d3d11/renderer11_utils.cpp b/src/libANGLE/renderer/d3d/d3d11/renderer11_utils.cpp
index 6cc6949..e4ba9cc 100644
--- a/src/libANGLE/renderer/d3d/d3d11/renderer11_utils.cpp
+++ b/src/libANGLE/renderer/d3d/d3d11/renderer11_utils.cpp
@@ -414,32 +414,6 @@ int GetMaximumSimultaneousRenderTargets(D3D_FEATURE_LEVEL featureLevel)
     }
 }
 
-int GetMaximum2DTextureSize(D3D_FEATURE_LEVEL featureLevel)
-{
-    switch (featureLevel)
-    {
-        case D3D_FEATURE_LEVEL_12_1:
-        case D3D_FEATURE_LEVEL_12_0:
-        case D3D_FEATURE_LEVEL_11_1:
-        case D3D_FEATURE_LEVEL_11_0:
-            return D3D11_REQ_TEXTURE2D_U_OR_V_DIMENSION;
-
-        case D3D_FEATURE_LEVEL_10_1:
-        case D3D_FEATURE_LEVEL_10_0:
-            return D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION;
-
-        case D3D_FEATURE_LEVEL_9_3:
-            return D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION;
-        case D3D_FEATURE_LEVEL_9_2:
-        case D3D_FEATURE_LEVEL_9_1:
-            return D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION;
-
-        default:
-            UNREACHABLE();
-            return 0;
-    }
-}
-
 int GetMaximumCubeMapTextureSize(D3D_FEATURE_LEVEL featureLevel)
 {
     switch (featureLevel)
@@ -1388,7 +1362,7 @@ void GenerateCaps(ID3D11Device *device,
     // Reserve MAX_UINT for D3D11's primitive restart.
     caps->maxElementIndex  = static_cast<GLint64>(std::numeric_limits<unsigned int>::max() - 1);
     caps->max3DTextureSize = GetMaximum3DTextureSize(featureLevel);
-    caps->max2DTextureSize = GetMaximum2DTextureSize(featureLevel);
+    caps->max2DTextureSize = 16384;
     caps->maxCubeMapTextureSize = GetMaximumCubeMapTextureSize(featureLevel);
     caps->maxArrayTextureLayers = GetMaximum2DTextureArraySize(featureLevel);
 
diff --git a/src/libANGLE/renderer/d3d/d3d9/renderer9_utils.cpp b/src/libANGLE/renderer/d3d/d3d9/renderer9_utils.cpp
index 52e9cda..86c1ba8 100644
--- a/src/libANGLE/renderer/d3d/d3d9/renderer9_utils.cpp
+++ b/src/libANGLE/renderer/d3d/d3d9/renderer9_utils.cpp
@@ -534,7 +534,7 @@ void GenerateCaps(IDirect3D9 *d3d9,
     caps->max3DTextureSize = 1;
 
     // Only one limit in GL, use the minimum dimension
-    caps->max2DTextureSize = std::min(deviceCaps.MaxTextureWidth, deviceCaps.MaxTextureHeight);
+    caps->max2DTextureSize = 16384;
 
     // D3D treats cube maps as a special case of 2D textures
     caps->maxCubeMapTextureSize = caps->max2DTextureSize;
diff --git a/src/libANGLE/renderer/gl/renderergl_utils.cpp b/src/libANGLE/renderer/gl/renderergl_utils.cpp
index a2c6e47..2e0608f 100644
--- a/src/libANGLE/renderer/gl/renderergl_utils.cpp
+++ b/src/libANGLE/renderer/gl/renderergl_utils.cpp
@@ -816,7 +816,7 @@ void GenerateCaps(const FunctionsGL *functions,
         LimitVersion(maxSupportedESVersion, gl::Version(2, 0));
     }
 
-    caps->max2DTextureSize = QuerySingleGLInt(functions, GL_MAX_TEXTURE_SIZE);  // GL 1.0 / ES 2.0
+    caps->max2DTextureSize = 16384;  // GL 1.0 / ES 2.0
     caps->maxCubeMapTextureSize =
         QuerySingleGLInt(functions, GL_MAX_CUBE_MAP_TEXTURE_SIZE);  // GL 1.3 / ES 2.0
 
@@ -848,12 +848,12 @@ void GenerateCaps(const FunctionsGL *functions,
         functions->hasGLExtension("GL_EXT_framebuffer_object") ||
         functions->isAtLeastGLES(gl::Version(3, 0)))
     {
-        caps->maxRenderbufferSize = QuerySingleGLInt(functions, GL_MAX_RENDERBUFFER_SIZE);
+        caps->maxRenderbufferSize = 16384;
         caps->maxColorAttachments = QuerySingleGLInt(functions, GL_MAX_COLOR_ATTACHMENTS);
     }
     else if (functions->isAtLeastGLES(gl::Version(2, 0)))
     {
-        caps->maxRenderbufferSize = QuerySingleGLInt(functions, GL_MAX_RENDERBUFFER_SIZE);
+        caps->maxRenderbufferSize = 16384;
         caps->maxColorAttachments = 1;
     }
     else
@@ -1236,10 +1236,10 @@ void GenerateCaps(const FunctionsGL *functions,
     if (functions->isAtLeastGL(gl::Version(4, 3)) || functions->isAtLeastGLES(gl::Version(3, 1)) ||
         functions->hasGLExtension("GL_ARB_framebuffer_no_attachments"))
     {
-        caps->maxFramebufferWidth  = QuerySingleGLInt(functions, GL_MAX_FRAMEBUFFER_WIDTH);
-        caps->maxFramebufferHeight = QuerySingleGLInt(functions, GL_MAX_FRAMEBUFFER_HEIGHT);
+        caps->maxFramebufferWidth  = 16384;
+        caps->maxFramebufferHeight = 16384;
         caps->maxFramebufferSamples =
-            std::min(QuerySingleGLInt(functions, GL_MAX_FRAMEBUFFER_SAMPLES), sampleCountLimit);
+            16384;
     }
     else
     {
@@ -1882,7 +1882,7 @@ void GenerateCaps(const FunctionsGL *functions,
     {
         extensions->textureRectangleANGLE = true;
         caps->maxRectangleTextureSize =
-            QuerySingleGLInt(functions, GL_MAX_RECTANGLE_TEXTURE_SIZE_ANGLE);
+            16384;
     }
 
     // OpenGL 4.3 (and above) and OpenGL ES 3.2 can support all features and constants defined in
diff --git a/src/libANGLE/renderer/metal/DisplayMtl.mm b/src/libANGLE/renderer/metal/DisplayMtl.mm
index 41bc271..02989ef 100644
--- a/src/libANGLE/renderer/metal/DisplayMtl.mm
+++ b/src/libANGLE/renderer/metal/DisplayMtl.mm
@@ -726,7 +726,7 @@ void DisplayMtl::ensureCapsInitialized() const
     mNativeCaps.maxVaryingVectors         = 31 - 1;
     mNativeCaps.maxVertexOutputComponents = mNativeCaps.maxFragmentInputComponents = 124 - 4;
 #elif TARGET_OS_SIMULATOR
-    mNativeCaps.max2DTextureSize          = 8192;
+    mNativeCaps.max2DTextureSize          = 16384;
     mNativeCaps.maxVaryingVectors         = 31 - 1;
     mNativeCaps.maxVertexOutputComponents = mNativeCaps.maxFragmentInputComponents = 124 - 4;
 #else
@@ -738,7 +738,7 @@ void DisplayMtl::ensureCapsInitialized() const
     }
     else
     {
-        mNativeCaps.max2DTextureSize          = 8192;
+        mNativeCaps.max2DTextureSize          = 16384;
         mNativeCaps.maxVertexOutputComponents = mNativeCaps.maxFragmentInputComponents = 60;
         mNativeCaps.maxVaryingVectors = mNativeCaps.maxVertexOutputComponents / 4;
     }
diff --git a/src/libANGLE/renderer/vulkan/CLDeviceVk.cpp b/src/libANGLE/renderer/vulkan/CLDeviceVk.cpp
index b395697..37f1953 100644
--- a/src/libANGLE/renderer/vulkan/CLDeviceVk.cpp
+++ b/src/libANGLE/renderer/vulkan/CLDeviceVk.cpp
@@ -177,8 +177,8 @@ CLDeviceImpl::Info CLDeviceVk::createInfo(cl::DeviceType type) const
 
     info.imageSupport = CL_TRUE;
 
-    info.image2D_MaxWidth  = properties.limits.maxImageDimension2D;
-    info.image2D_MaxHeight = properties.limits.maxImageDimension2D;
+    info.image2D_MaxWidth  = 16384;
+    info.image2D_MaxHeight = 16384;
     info.image3D_MaxWidth  = properties.limits.maxImageDimension3D;
     info.image3D_MaxHeight = properties.limits.maxImageDimension3D;
     info.image3D_MaxDepth  = properties.limits.maxImageDimension3D;
diff --git a/src/libANGLE/renderer/vulkan/vk_caps_utils.cpp b/src/libANGLE/renderer/vulkan/vk_caps_utils.cpp
index 4102464..c8748a7 100644
--- a/src/libANGLE/renderer/vulkan/vk_caps_utils.cpp
+++ b/src/libANGLE/renderer/vulkan/vk_caps_utils.cpp
@@ -658,14 +658,12 @@ void Renderer::ensureCapsInitialized() const
     mNativeCaps.maxElementIndex = (1 << 30) - 1;
 
     mNativeCaps.max3DTextureSize = rx::LimitToInt(limitsVk.maxImageDimension3D);
-    mNativeCaps.max2DTextureSize =
-        std::min(limitsVk.maxFramebufferWidth, limitsVk.maxImageDimension2D);
+    mNativeCaps.max2DTextureSize = 16384;
     mNativeCaps.maxArrayTextureLayers = rx::LimitToInt(limitsVk.maxImageArrayLayers);
     mNativeCaps.maxLODBias            = limitsVk.maxSamplerLodBias;
     mNativeCaps.maxCubeMapTextureSize = rx::LimitToInt(limitsVk.maxImageDimensionCube);
     mNativeCaps.maxRenderbufferSize =
-        std::min({limitsVk.maxImageDimension2D, limitsVk.maxFramebufferWidth,
-                  limitsVk.maxFramebufferHeight});
+        16384;
     mNativeCaps.minAliasedPointSize = std::max(1.0f, limitsVk.pointSizeRange[0]);
     mNativeCaps.maxAliasedPointSize = limitsVk.pointSizeRange[1];
 
@@ -686,11 +684,11 @@ void Renderer::ensureCapsInitialized() const
 
     mNativeCaps.maxDrawBuffers =
         std::min(limitsVk.maxColorAttachments, limitsVk.maxFragmentOutputAttachments);
-    mNativeCaps.maxFramebufferWidth  = rx::LimitToInt(limitsVk.maxFramebufferWidth);
-    mNativeCaps.maxFramebufferHeight = rx::LimitToInt(limitsVk.maxFramebufferHeight);
+    mNativeCaps.maxFramebufferWidth  = 16384;
+    mNativeCaps.maxFramebufferHeight = 16384;
     mNativeCaps.maxColorAttachments  = rx::LimitToInt(limitsVk.maxColorAttachments);
-    mNativeCaps.maxViewportWidth     = rx::LimitToInt(limitsVk.maxViewportDimensions[0]);
-    mNativeCaps.maxViewportHeight    = rx::LimitToInt(limitsVk.maxViewportDimensions[1]);
+    mNativeCaps.maxViewportWidth     = 16384;
+    mNativeCaps.maxViewportHeight    = 16384;
     mNativeCaps.maxSampleMaskWords   = rx::LimitToInt(limitsVk.maxSampleMaskWords);
     mNativeCaps.maxColorTextureSamples =
         vk_gl::GetMaxSampleCount(limitsVk.sampledImageColorSampleCounts);
@@ -1567,12 +1565,7 @@ EGLint ComputeMaximumPBufferPixels(const VkPhysicalDeviceProperties &physicalDev
     // http://anglebug.com/42261335
 
     // Storing the result of squaring a 32-bit unsigned int in a 64-bit unsigned int is safe.
-    static_assert(std::is_same<decltype(physicalDeviceProperties.limits.maxImageDimension2D),
-                               uint32_t>::value,
-                  "physicalDeviceProperties.limits.maxImageDimension2D expected to be a uint32_t.");
-    const uint64_t maxDimensionsSquared =
-        static_cast<uint64_t>(physicalDeviceProperties.limits.maxImageDimension2D) *
-        static_cast<uint64_t>(physicalDeviceProperties.limits.maxImageDimension2D);
+    const uint64_t maxDimensionsSquared = 16384ull * 16384ull;
 
     return static_cast<EGLint>(std::min(maxDimensionsSquared, kMaxValueForEGLint));
 }
@@ -1630,8 +1623,8 @@ egl::Config GenerateDefaultConfig(DisplayVk *display,
     config.stencilSize        = depthStencilFormat.stencilBits;
     config.level              = 0;
     config.matchNativePixmap  = EGL_NONE;
-    config.maxPBufferWidth    = physicalDeviceProperties.limits.maxImageDimension2D;
-    config.maxPBufferHeight   = physicalDeviceProperties.limits.maxImageDimension2D;
+    config.maxPBufferWidth    = 16384;
+    config.maxPBufferHeight   = 16384;
     config.maxPBufferPixels   = ComputeMaximumPBufferPixels(physicalDeviceProperties);
     config.maxSwapInterval    = 1;
     config.minSwapInterval    = 0;
diff --git a/src/libANGLE/renderer/wgpu/wgpu_utils.cpp b/src/libANGLE/renderer/wgpu/wgpu_utils.cpp
index 355ea94..f220d19 100644
--- a/src/libANGLE/renderer/wgpu/wgpu_utils.cpp
+++ b/src/libANGLE/renderer/wgpu/wgpu_utils.cpp
@@ -265,11 +265,11 @@ void GenerateCaps(const WGPULimits &limitsWgpu,
     // OpenGL ES caps
     glCaps->maxElementIndex       = std::numeric_limits<GLuint>::max() - 1;
     glCaps->max3DTextureSize      = rx::LimitToInt(limitsWgpu.maxTextureDimension3D);
-    glCaps->max2DTextureSize      = rx::LimitToInt(limitsWgpu.maxTextureDimension2D);
+    glCaps->max2DTextureSize      = 16384;
     glCaps->maxArrayTextureLayers = rx::LimitToInt(limitsWgpu.maxTextureArrayLayers);
     glCaps->maxLODBias            = 0.0f;
-    glCaps->maxCubeMapTextureSize = rx::LimitToInt(limitsWgpu.maxTextureDimension2D);
-    glCaps->maxRenderbufferSize   = rx::LimitToInt(limitsWgpu.maxTextureDimension2D);
+    glCaps->maxCubeMapTextureSize = 16384;
+    glCaps->maxRenderbufferSize   = 16384;
     glCaps->minAliasedPointSize   = 1.0f;
     glCaps->maxAliasedPointSize   = 1.0f;
     glCaps->minAliasedLineWidth   = 1.0f;
@@ -279,12 +279,12 @@ void GenerateCaps(const WGPULimits &limitsWgpu,
     constexpr uint32_t kMaxSampleCount = 4;
 
     glCaps->maxDrawBuffers         = rx::LimitToInt(limitsWgpu.maxColorAttachments);
-    glCaps->maxFramebufferWidth    = rx::LimitToInt(limitsWgpu.maxTextureDimension2D);
-    glCaps->maxFramebufferHeight   = rx::LimitToInt(limitsWgpu.maxTextureDimension2D);
+    glCaps->maxFramebufferWidth    = 16384;
+    glCaps->maxFramebufferHeight   = 16384;
     glCaps->maxFramebufferSamples  = kMaxSampleCount;
     glCaps->maxColorAttachments    = rx::LimitToInt(limitsWgpu.maxColorAttachments);
-    glCaps->maxViewportWidth       = rx::LimitToInt(limitsWgpu.maxTextureDimension2D);
-    glCaps->maxViewportHeight      = glCaps->maxViewportWidth;
+    glCaps->maxViewportWidth       = 16384;
+    glCaps->maxViewportHeight      = 16384;
     glCaps->maxSampleMaskWords     = 1;
     glCaps->maxColorTextureSamples = kMaxSampleCount;
     glCaps->maxDepthTextureSamples = kMaxSampleCount;
-- 
2.52.0

